use convolutions_rs::{transposed_convolutions::TransposedConvolutionLayer, Padding};
use ndarray::{Array, Array3, Array4, Dimension};
use ndarray_npy::read_npy;

fn arr_allclose<D: Dimension>(current: &Array<f32, D>, target: &Array<f32, D>) -> bool {
    assert_eq!(
        current.shape(),
        target.shape(),
        "\ngiven array had shape {:?}, but target had shape {:?}",
        current.shape(),
        target.shape()
    );
    (current - target).map(|x| (*x as f32).abs()).sum() < 1e-3
}

#[test]
fn test_fringe_case() {
    let kernel: Array4<f32> = read_npy("kernel.npy").unwrap();
    let output: Array3<f32> = read_npy("output.npy").unwrap();
    let input: Array3<f32> = read_npy("y_hat.npy").unwrap();
    let layer = TransposedConvolutionLayer::new_tf(kernel, 2, Padding::Same);
    let our_output = layer.transposed_convolve(&input);
    // generated via
    // while tf_to_pt is just np.squeeze + np.moveaxis(2,0)
    // and the tf versions are generated by adding an axis and np.moveaxis(1,3)
    // np.save("output.npy", tf_to_pt((tf.nn.conv2d_transpose(y_hat_tf, weight, out1_tf.shape, strides
    // ...: =2, padding="SAME").numpy())))
    assert!(
        arr_allclose(&output, &our_output),
        "{:?} and {:?} not identical",
        output,
        our_output
    );
}
